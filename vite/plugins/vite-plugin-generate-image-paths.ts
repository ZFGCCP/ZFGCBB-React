import { Plugin, ViteDevServer } from "vite";
import { promises as fs } from "node:fs";
import path from "node:path";
import type BBImage from "../../src/components/common/bbImage.component";

interface ImagePathPluginOptions {
  assetsPath?: string;
  outputFile?: string;
  includeDirs?: string[];
  debug?: boolean;
}

function defaultOptions(): Required<ImagePathPluginOptions> {
  return {
    assetsPath: "src/assets",
    outputFile: "build/types/image-paths.d.ts",
    includeDirs: ["images", "themes"],
    debug: false,
  };
}

async function walk(dir: string): Promise<string[]> {
  const entries = await fs
    .readdir(dir, { withFileTypes: true })
    .catch(() => []);
  const files = await Promise.all(
    entries.map((entry) => {
      const fullPath = path.join(dir, entry.name);
      return entry.isDirectory() ? walk(fullPath) : fullPath;
    }),
  );
  return files.flat();
}

function toPascalCase(input: string): string {
  return (
    input.replace(/(^\w|-\w|_\w)/g, (m) =>
      m.replace(/[-_]/, "").toUpperCase(),
    ) + "Path"
  );
}

async function generateTypeFile(options: Required<ImagePathPluginOptions>) {
  const assetsAbsPath = path.resolve(process.cwd(), options.assetsPath);
  const outputPath = path.resolve(process.cwd(), options.outputFile);
  const outputDir = path.dirname(outputPath);

  await fs.mkdir(outputDir, { recursive: true });

  const typeBlocks: string[] = [];

  for (const subDir of options.includeDirs) {
    const fullDir = path.join(assetsAbsPath, subDir);
    const files = await walk(fullDir);
    const relativeFiles = files.map((file) =>
      path.relative(assetsAbsPath, file).replace(/\\/g, "/"),
    );

    const typeName = toPascalCase(subDir); // e.g., ImagePath, ThemePath
    const literals =
      relativeFiles.map((f) => `"${f}"`).join(" |\n    ") || "never";

    // FIXME: #112 fix: add support for scanning assets(images, videos, etc.) in sub-directories to inject width/height attributes so BBImage can render the fallback at the correct size

    typeBlocks.push(`  export type ${typeName} =\n    ${literals};`);
  }

  const newBlock = `
// --- GENERATED BY vite-plugin-generate-image-paths ---
declare global {
${typeBlocks.join("\n\n")}
}

export {};
// --- END GENERATED BY vite-plugin-generate-image-paths ---
`.trim();

  await fs.writeFile(outputPath, newBlock + "\n", "utf-8");
  if (options.debug)
    console.debug(
      `[vite-plugin-generate-image-paths] Wrote: ${options.outputFile}`,
    );
}

/**
 * Since we have {@link BBImage} component, we need to generate a type file for the image paths in the provided assets directory.
 * It supports both absolute and relative paths, and can be configured to include
 * specific directories or to exclude certain directories.
 *
 * Usage:
 * ```ts
 * // vite.config.ts
 * import { defineConfig } from "vite";
 * import { generateImagePaths } from "./vite/plugins/vite-plugin-generate-image-paths";
 *
 * export default defineConfig({
 *   plugins: [
 *     generateImagePaths({
 *       // These are the default options.
 *       assetsPath: "src/assets",
 *       outputFile: "build/types/image-paths.d.ts",
 *       includeDirs: ["images", "themes"],
 *       // debug: true, // Uncomment to enable debug logging
 *     }),
 *   ],
 * });
 * ```
 *
 * @param userOptions - The options to pass to the plugin.
 * @see {@link BBImage}
 */
export function generateImagePaths(
  userOptions: ImagePathPluginOptions = {},
): Plugin {
  const options = { ...defaultOptions(), ...userOptions };

  return {
    name: "vite-plugin-generate-image-paths",
    apply: "serve", // Run in dev and build mode
    async buildStart() {
      // Generate the type file before build starts
      await generateTypeFile(options);
    },
    async configureServer(server: ViteDevServer) {
      // Generate type file for the first time when server is configured
      await generateTypeFile(options);

      const watchDirs = options.includeDirs.map((d) =>
        path.resolve(process.cwd(), options.assetsPath, d),
      );

      for (const dir of watchDirs) {
        server.watcher.add(dir);
      }

      const isWatchedPath = (filePath: string) =>
        filePath.startsWith(path.resolve(process.cwd(), options.assetsPath));

      // On file additions and deletions, regenerate type file
      server.watcher.on("add", async (file) => {
        if (isWatchedPath(file)) {
          await generateTypeFile(options);
        }
      });

      server.watcher.on("unlink", async (file) => {
        if (isWatchedPath(file)) {
          await generateTypeFile(options);
        }
      });
    },
    // Build hook to ensure the type file gets generated during production build
    async closeBundle() {
      await generateTypeFile(options);
    },
  };
}

import { Plugin, ViteDevServer } from "vite";
import { promises as fs } from "node:fs";
import path from "node:path";

interface ImagePathPluginOptions {
  assetsPath?: string;
  outputFile?: string;
  includeDirs?: string[];
  debug?: boolean;
}

function defaultOptions(): Required<ImagePathPluginOptions> {
  return {
    assetsPath: "src/assets",
    outputFile: "build/types/image-paths.d.ts",
    includeDirs: ["images", "themes"],
    debug: false,
  };
}

async function walk(dir: string): Promise<string[]> {
  const entries = await fs
    .readdir(dir, { withFileTypes: true })
    .catch(() => []);
  const files = await Promise.all(
    entries.map((entry) => {
      const fullPath = path.join(dir, entry.name);
      return entry.isDirectory() ? walk(fullPath) : fullPath;
    }),
  );
  return files.flat();
}

function toPascalCase(input: string): string {
  return (
    input.replace(/(^\w|-\w|_\w)/g, (m) =>
      m.replace(/[-_]/, "").toUpperCase(),
    ) + "Path"
  );
}

async function generateTypeFile(options: Required<ImagePathPluginOptions>) {
  const assetsAbsPath = path.resolve(process.cwd(), options.assetsPath);
  const outputPath = path.resolve(process.cwd(), options.outputFile);
  const outputDir = path.dirname(outputPath);

  await fs.mkdir(outputDir, { recursive: true });

  const typeBlocks: string[] = [];

  for (const subDir of options.includeDirs) {
    const fullDir = path.join(assetsAbsPath, subDir);
    const files = await walk(fullDir);
    const relativeFiles = files.map((file) =>
      path.relative(assetsAbsPath, file).replace(/\\/g, "/"),
    );

    const typeName = toPascalCase(subDir); // e.g., ImagePath, ThemePath
    const literals =
      relativeFiles.map((f) => `"${f}"`).join(" |\n    ") || "never";

    typeBlocks.push(`  export type ${typeName} =\n    ${literals};`);
  }

  const newBlock = `
// --- GENERATED BY vite-plugin-generate-image-paths ---
declare global {
${typeBlocks.join("\n\n")}
}

export {};
// --- END GENERATED BY vite-plugin-generate-image-paths ---
`.trim();

  let originalContent = "";

  try {
    originalContent = await fs.readFile(outputPath, "utf-8");
  } catch {
    if (options.debug)
      console.debug(
        `[vite-plugin-generate-image-paths] Creating new: ${options.outputFile}`,
      );
  }

  const strippedContent = originalContent.replace(
    /\/\/ --- GENERATED BY vite-plugin-generate-image-paths ---[\s\S]*?\/\/ --- END GENERATED BY vite-plugin-generate-image-paths ---/g,
    "",
  );

  const finalContent = `${strippedContent.trim()}\n\n${newBlock}\n`;

  await fs.writeFile(outputPath, finalContent.trim() + "\n", "utf-8");
  if (options.debug)
    console.debug(
      `[vite-plugin-generate-image-paths] Wrote: ${options.outputFile}`,
    );
}

export function generateImagePaths(
  userOptions: ImagePathPluginOptions = {},
): Plugin {
  const options = { ...defaultOptions(), ...userOptions };

  return {
    name: "vite-plugin-generate-image-paths",
    apply: "serve", // dev and build
    async buildStart() {
      await generateTypeFile(options);
    },
    async configureServer(server: ViteDevServer) {
      await generateTypeFile(options);

      const watchDirs = options.includeDirs.map((d) =>
        path.resolve(process.cwd(), options.assetsPath, d),
      );

      for (const dir of watchDirs) {
        server.watcher.add(dir);
      }

      const isWatchedPath = (filePath: string) =>
        filePath.startsWith(path.resolve(process.cwd(), options.assetsPath));

      server.watcher.on("add", async (file) => {
        if (isWatchedPath(file)) {
          await generateTypeFile(options);
        }
      });

      server.watcher.on("unlink", async (file) => {
        if (isWatchedPath(file)) {
          await generateTypeFile(options);
        }
      });
    },
  };
}
